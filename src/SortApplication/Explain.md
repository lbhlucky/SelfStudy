# Sort Application

## Key Points

### 조건
    1. 정렬 조건이 필요하다.
        > implements Comparable<타입>
            - 항상 int형을 return 하는 compareTo() override 해야함
                case1) return 음수 : 내가 먼저
                case2) return 양수 : 쟤(other)가 먼저
                case3) return 0 : 우리는 친구

    2. 시간 복잡도는 약 O(N log N) 이다
        > N개의 원소를 정렬하는 것은 O(N log N)
            ex) 10만개를 정렬한다면 약 160만 번의 연산이 필요하다. => 1초안에 가능

    3. In-place / Stable 여부를 알아야한다.
        > 이 정렬이 In-place(제자리)한가?
            - 정렬하는 과정에서 N에 비해 충분히 무시할 만한 개수의 메모리만큼만 추가적으로 사용하는가?
            ex) 10만개의 정렬을 해야하는게 10개가 추가되면 무시해도됨
        > 이 정렬이 Stable(안정)한가?
            - 동등한 위상의 원소들의 순서관계가 보존되는가?
            ex) 비교불가능한 두 대상에서 정렬해서 동일하게 나오면 Stable

### 특성
    1. 같은 정보들은 인접해 있을 것이다.

    2. 각 소마다, 가장 비슷한 순서의 다른 원소는 자신의 양 옆이다.
        >> 가장 가까운 원소의 위치는 N-1, N+1 이다.
    
    3. 정렬만 해도 문제가 쉽게 풀리는 경우가 상당히 많다.




