<h1>위상 정렬(Topological Sort)</h1>

<h3> 위상 정렬 : 위상 + 정렬 </h3>
=> 정점들을 위상에 맞게 정렬한다.

<br>

<h5> ※ Directed Acyclic Graph(DAG) </h5>

- Directed := 간선에 방향이 있다.   
  - a -> b := a에서 b로
- Acyclic := Cyclic이 없다.
- Graph := 정점(V) + 간선(E)

<h5> ※ 차수(Degree) </h5>

방향성(Directed) Graph에서
- Indegree : 안으로 들어오는 간선
- Outdegree : 밖으로 나가는 간선

<h3>위상 정렬; 하나씩 정렬하기!</h3>
- 아이디어 : "제일 먼저 올 수 있는 정점은?"      
   Q  "제일 먼저" 올 수 있는 정점은?   
   A "들어오는 간선"이 없는 정점!
- 하나씩 정렬시켜 버리면서 그래프에서 삭제하자!

<h3> 위상 정렬; 정리 </h3>   

1. 정점들의 Indegree, Indeg[1...N] 계산하기  
2. 들어오는 간선이 0개인 (Indeg[i] == 0) 정점들을 찾아서 자료구조 D에 넣기
3. D가 빌 때까지
   1. D에서 원소 X를 꺼내서 "정렬" 시키기
   2. Graph 에서 정점 X "제거" 하기
   3. "새롭게 정렬 가능한 점"을 찾아서 D에 넣기

<h3> 위상 정렬; 구현 방법 </h3>

1. 정점들의 Indegree, Indeg[1...N] 계산하기
    1. 자료 구조 D에 필요한 연산은?
       - 원소를 추가하기
       - 원소를 꺼내기   
    
=> 두 연산을 "빠르게" 해주는 것은? "Queue", Stack, LinkedK List, etc..

2. 들어오는 간선이 0개인 (Indeg[i] == 0) 정점들을 찾아서 자료구조 D에 넣기
3. D가 빌 때까지 원소 X를 꺼내서 "정렬" 시키고, "제거" 하고,   
   "새롭게 정렬 가능한 점"을 찾아서 D에 넣기   
<h4>=> O(|V| + |E|)</h4>